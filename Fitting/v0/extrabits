 //write the diagnostic 2d plot to the outfile and then add the table extension below. 

    // declare auto-pointer to FITS at function scope. Ensures no resources
    // leaked if something fails in dynamic allocation.
  
    std::auto_ptr<FITS> pFits(0);
      
    try
      {                
        // overwrite existing file if the file already exists.     
	const std::string fileName("temp_chain.fits");            
	pFits.reset( new FITS(fileName,Write) );
      }
    catch (FITS::CantCreate)
      {
	return -1;       
      }

    unsigned long rows(runs); 

    string hduName("MC Chain");  
    std::vector<string> colName(12,"");
    std::vector<string> colForm(12,"");
    std::vector<string> colUnit(12,"");
    
   
    colName[0] = "Par1";
    colName[1] = "Par2";

    colName[2] = "dndz1";
    colName[3] = "dndz2";
    colName[4] = "dndz3";
    colName[5] = "dndz4";
    colName[6] = "dndz5";
    colName[7] = "dndz6";
    colName[8] = "dndz7";
    colName[9] = "dndz8";
    colName[10] = "dndz9";
    colName[11] = "dndz10";

    colName[12] = "chi2";

    colForm[0] = "f4.2";
    colForm[1] = "f4.2";

    colForm[2] = "i6";
    colForm[3] = "i6";
    colForm[4] = "i6";
    colForm[5] = "i6";
    colForm[6] = "i6";
    colForm[7] = "i6";
    colForm[8] = "i6";
    colForm[9] = "i6";
    colForm[10] = "i6";
    colForm[11] = "i6";

    colForm[12] = "f8.2";

    colUnit[0] = "";
    colUnit[1] = "";
    colUnit[2] = "";    

    Table* newTable = savefile->addTable(hduName,rows,colName,colForm,colUnit,AsciiTbl);

    std::vector<float> par1(rows);
    std::vector<float> par2(rows);

    std::vector<int> dndz1(rows);
    std::vector<int> dndz2(rows);
    std::vector<int> dndz3(rows);
    std::vector<int> dndz4(rows);
    std::vector<int> dndz5(rows);
    std::vector<int> dndz6(rows);
    std::vector<int> dndz7(rows);
    std::vector<int> dndz8(rows);
    std::vector<int> dndz9(rows);
    std::vector<int> dndz10(rows);

    std::vector<float> chi2(rows);

    //   size_t j = 0;    

  goto skipchainfits;
    for (size_t j=0 ; j < rows; ++j) {
      par1[j] = chain[0][j];
      par2[j] = chain[1][j];

      dndz1[j] = int (chain[2][j]);
      dndz2[j] = int (chain[3][j]);
      dndz3[j] = int (chain[4][j]);
      dndz4[j] = int (chain[5][j]);
      dndz5[j] = int (chain[6][j]);
      dndz6[j] = int (chain[7][j]);
      dndz7[j] = int (chain[8][j]);
      dndz8[j] = int (chain[9][j]);
      dndz9[j] = int (chain[10][j]);
      dndz10[j] = int (chain[11][j]);

      chi2[j] = chain[20][j]; //there's a gap as need the dnds as well. 
    }

    try
      {                
        newTable->column(colName[0]).write(par1,1);  
        newTable->column(colName[1]).write(par2,1);

        newTable->column(colName[2]).write(dndz1,1);
        newTable->column(colName[3]).write(dndz2,1);
        newTable->column(colName[4]).write(dndz3,1);
        newTable->column(colName[5]).write(dndz4,1);
        newTable->column(colName[6]).write(dndz5,1);
        newTable->column(colName[7]).write(dndz6,1);
        newTable->column(colName[8]).write(dndz7,1);
        newTable->column(colName[9]).write(dndz8,1);
        newTable->column(colName[10]).write(dndz9,1);
        newTable->column(colName[11]).write(dndz10,1);

        newTable->column(colName[12]).write(chi2,1);
      }
    catch (FitsException&)
      {
         // ExtHDU::column could in principle throw a NoSuchColumn exception,
         // or some other fits error may ensue.
         std::cerr << " Error in writing to columns - check e.g. that columns of specified name "
                        << " exist in the extension \n";
                               
      }
    

// write the data string.
    newTable->writeDate();
   
    // and see if it all worked right.
    std::cout << *newTable << std::endl;
    
 skipchainfits: